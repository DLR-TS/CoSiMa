# CMakeList.txt: CMake-Projektdatei der obersten Ebene.
#
cmake_minimum_required (VERSION 3.8)
message("Running with CMake Version ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}.${CMAKE_PATCH_VERSION}")

project ("CoSimulationManager" CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

option(GIT_SUBMODULE "Check submodules during build" ON)
if(GIT_SUBMODULE)
	find_package(Git QUIET)
	if(GIT_FOUND AND EXISTS "${PROJECT_SOURCE_DIR}/.git")
		message(STATUS "Updating submodules")
		execute_process(COMMAND ${GIT_EXECUTABLE} submodule update --init --recursive
						WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
						RESULT_VARIABLE GIT_SUBMODULE_RESULT)
		if(NOT GIT_SUBMODULE_RESULT EQUAL "0")
			message(FATAL_ERROR "git submodule update --init --recursive failed with ${GIT_SUBMODULE_RESULT}")
		endif()
	endif()
endif()

# Download automatically, you can also just copy the conan.cmake file
if(NOT EXISTS "${CMAKE_BINARY_DIR}/conan.cmake")
   message(STATUS "Downloading conan.cmake from https://github.com/conan-io/cmake-conan")
   file(DOWNLOAD "https://github.com/conan-io/cmake-conan/raw/v0.15/conan.cmake"
                 "${CMAKE_BINARY_DIR}/conan.cmake")
endif()

include(${CMAKE_BINARY_DIR}/conan.cmake)

# get dependencies distributed as conan packages
conan_cmake_run(CONANFILE conanfile.txt 
                BASIC_SETUP CMAKE_TARGETS
                BUILD missing)

# include protobuf, yaml_cpp, catch2, fakeit
include(${CMAKE_CURRENT_BINARY_DIR}/conanbuildinfo.cmake)
# needed by cmake_find_package conan generator, but breaks protobuf
#include(${CMAKE_CURRENT_BINARY_DIR}/conan_paths.cmake)
conan_basic_setup()

# FMI4cpp is not distributed as conan package, but still can use conan for dependency management.
# Still, we aren't using FMI4cpp's conanfile.txt and instead merge its conent into our conanfile.txt to have control of the used conan packages.
# This allows us to unify package versions and remove unneeded options. (libzip:with_openssl introduces dependency on openssl, which collides with gRPC's boringssl)
add_subdirectory(lib/FMI4cpp/ EXCLUDE_FROM_ALL)

# add OSI as cmake subproject
add_subdirectory ("lib/open-simulation-interface" EXCLUDE_FROM_ALL)

# Findprotobuf.cmake generated by cmake_find_package conan generator is missing some definitons from the default find script, but catch2 is not found without a defintion for find_package
# => We use our own FindCatch2.cmake module
set(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/CMakeModules ${CMAKE_MODULE_PATH})

# use our FetchGRPC.cmake module to add gRPC
set(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/CMakeModules ${CMAKE_MODULE_PATH})
include(FetchGRPC)

#main project
# set up variables that are used below
add_subdirectory("src")
add_subdirectory("include")
add_subdirectory("test")

option(WITH_CARLA "Build CoSimulationManagerLib with CARLA base simulaton interface" ON)
if(WITH_CARLA)
    message(STATUS "Will add CARLA base interface to build")
endif(WITH_CARLA)

#create library to
add_library(CoSimulationManagerLib ${COSIMA_SOURCE} ${COSIMA_INCLUDES})
# CoSimulationManagerLib exports no symbols, thereby preventing linking of its dll on windows. Force export of all global symbols
set_property(TARGET CoSimulationManagerLib PROPERTY WINDOWS_EXPORT_ALL_SYMBOLS ON)
target_include_directories(CoSimulationManagerLib PUBLIC ${CMAKE_CURRENT_LIST_DIR}/include)
# link conan managed dependencies
target_link_libraries(CoSimulationManagerLib PUBLIC CONAN_PKG::protobuf CONAN_PKG::yaml-cpp)
# add grpc dependency
target_link_libraries(CoSimulationManagerLib PUBLIC grpc++)
# FMI4cpp is not managed by conan, thus it is added here
target_include_directories(CoSimulationManagerLib PUBLIC fmi4cpp)
target_link_libraries(CoSimulationManagerLib PUBLIC fmi4cpp)

# OSI is not managed by conan, thus it is added here
target_include_directories(CoSimulationManagerLib PUBLIC open_simulation_interface_obj)#shared base of both static and shared OSI lib targets
# OSI has differently named targets for static and shared build
if(BUILD_SHARED_LIBS)
	# By default, OSI exports no symbols when building a dll, preventing linking to the shared library on windows. Force export of all global symbols
	set_property(TARGET open_simulation_interface PROPERTY WINDOWS_EXPORT_ALL_SYMBOLS ON)
	target_link_libraries(CoSimulationManagerLib PUBLIC open_simulation_interface)
else()
	target_link_libraries(CoSimulationManagerLib PUBLIC open_simulation_interface_static)
endif(BUILD_SHARED_LIBS)


# generate grpc code
protobuf_generate_grpc_cpp(rpc/base_interface/BaseInterface.proto)#TODO define and add rpc/simulation_interface/SimulationInterface.proto)
target_include_directories(CoSimulationManagerLib PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/gens)

find_package(Catch2 REQUIRED)
add_executable(test_CoSiMa ${TESTFILES})
target_include_directories(test_CoSiMa PUBLIC ${CMAKE_CURRENT_LIST_DIR}/include)
target_link_libraries(test_CoSiMa PRIVATE CoSimulationManagerLib Catch2::Catch2)

#copy test resources to build folder
add_custom_command(TARGET test_CoSiMa PRE_BUILD
                     COMMAND ${CMAKE_COMMAND} -E
                         make_directory $<TARGET_FILE_DIR:test_CoSiMa>/../test/resources/)
#Feedthrough_cs_me.fmu contains definitions for both me and cs => created copies with edited modelDescription.xml
add_custom_command(TARGET test_CoSiMa PRE_BUILD
                     COMMAND ${CMAKE_COMMAND} -E
                         copy_if_different
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/testconfig1.yaml
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/testconfig2.yaml
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/testconfig3.yaml
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/Feedthrough_cs.fmu
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/Feedthrough_me.fmu
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/Stair.fmu
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/OSMPCNetworkProxy.fmu
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/OSMPDummySensor.fmu
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/OSMPDummySource.fmu
						 $<TARGET_FILE_DIR:test_CoSiMa>/../test/resources/)

include(CTest)
include(Catch)
catch_discover_tests(test_CoSiMa)

configure_file(${CMAKE_CURRENT_LIST_DIR}/include/CoSiMa.h.in ${CMAKE_CURRENT_BINARY_DIR}/include/CoSiMa.h)
#configure_file(${CMAKE_CURRENT_LIST_DIR}/src/CoSiMa.cpp.in ${CMAKE_CURRENT_BINARY_DIR}/src/CoSiMa.cpp)
add_executable (CoSimulationManager "${CMAKE_CURRENT_LIST_DIR}/src/CoSiMa.cpp" "${CMAKE_CURRENT_BINARY_DIR}/include/CoSiMa.h")
target_link_libraries(CoSimulationManager PUBLIC CoSimulationManagerLib)
target_include_directories(CoSimulationManager PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/include/)