cmake_minimum_required (VERSION 3.8)
project ("CoSimulationManager" CXX)

message("Running with CMake Version ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}.${CMAKE_PATCH_VERSION}")

if (NOT DEFINED CMAKE_CXX_STANDARD)
	set(CMAKE_CXX_STANDARD 17)
endif()
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

if(MSVC)
	option(DONT_FORCE_STATIC_LIBS "Building dynamic libraries fails for some targets because of incompatabilities in dependencies (protobuf, see FetchGRPC.cmake) and thus static lib's are enforced. Enable this option to abide CMAKE's BUILD_SHARED_LIBS variable" OFF)
	if(NOT DONT_FORCE_STATIC_LIBS)
		set(BUILD_SHARED_LIBS false)
		message("Forcing the use of static libraries as building dynamic libraries fails for some targets using MSVC because of incompatabilities in some dependencies. Enable DONT_FORCE_STATIC_LIBS to unforce this behaviour")
	endif(NOT DONT_FORCE_STATIC_LIBS)
endif(MSVC)

# Download automatically, you can also just copy the conan.cmake file
#if(NOT EXISTS "${CMAKE_BINARY_DIR}/conan.cmake")
# Somehow an empty conan.cmake file gets generated the first time in MSVC -> Always download the file.
   message(STATUS "Downloading conan.cmake from https://github.com/conan-io/cmake-conan")
   file(DOWNLOAD "https://raw.githubusercontent.com/conan-io/cmake-conan/0.18.1/conan.cmake"
                 "${CMAKE_BINARY_DIR}/conan.cmake")
#endif()

include(${CMAKE_BINARY_DIR}/conan.cmake)

# get dependencies distributed as conan packages
conan_cmake_run(CONANFILE conanfile.txt
                BASIC_SETUP CMAKE_TARGETS
                BUILD missing)

# include protobuf, yaml_cpp, catch2, fakeit
include(${CMAKE_CURRENT_BINARY_DIR}/conanbuildinfo.cmake)
# needed by cmake_find_package conan generator, but breaks protobuf
#include(${CMAKE_CURRENT_BINARY_DIR}/conan_paths.cmake)
conan_basic_setup()

# Somehow, sometimes the conan package's protoc binary is not found by the default find script, so help hinting it:
find_program(Protobuf_PROTOC_EXECUTABLE
    NAMES protoc
    DOC "The Google Protocol Buffers Compiler"
    HINTS
	${CONAN_BIN_DIRS}
)
if(Protobuf_PROTOC_EXECUTABLE)# Newer CMake versions define only upper case names
	set(PROTOBUF_PROTOC_EXECUTABLE ${Protobuf_PROTOC_EXECUTABLE})
endif()

# Findprotobuf.cmake generated by cmake_find_package conan generator is missing some definitons from the default find script, but catch2 is not found without a defintion for find_package
# => We use our own FindCatch2.cmake module
set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/CMakeModules ${CMAKE_MODULE_PATH})

# Read CMake_FetchContent_Overrides for changes of FetchContent_declare default of other included scripts
include(FetchContent)
include(${CMAKE_CURRENT_LIST_DIR}/CMake_FetchContent_Overrides.cmake OPTIONAL)

# use our FetchGRPC.cmake module to add gRPC
set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/CMakeModules ${CMAKE_MODULE_PATH})
include(FetchGRPC)

# OSI is not distributed as conan package, but we already took care of installig its dependency (protobuf), so we can just fetch it
include(FetchOpenSimulationInterface)

## main project
# set up variables that are used below
add_subdirectory("src")
add_subdirectory("include")
add_subdirectory("test")

#create library to
add_library(CoSimulationManagerLib ${COSIMA_SOURCE} ${COSIMA_INCLUDES})
# CoSimulationManagerLib exports no symbols, thereby preventing linking of its dll on windows. Force export of all global symbols
set_property(TARGET CoSimulationManagerLib PROPERTY WINDOWS_EXPORT_ALL_SYMBOLS ON)
target_include_directories(CoSimulationManagerLib PUBLIC ${CMAKE_CURRENT_LIST_DIR}/include)
# link conan managed dependencies
target_link_libraries(CoSimulationManagerLib PUBLIC CONAN_PKG::yaml-cpp)

# OSI is not managed by conan, thus it is added here
target_include_directories(CoSimulationManagerLib PUBLIC open_simulation_interface_obj)#shared base of both static and shared OSI lib targets
# OSI has differently named targets for static and shared build
if(BUILD_SHARED_LIBS)
	# By default, OSI exports no symbols when building a dll, preventing linking to the shared library on windows. Force export of all global symbols
	set_property(TARGET open_simulation_interface PROPERTY WINDOWS_EXPORT_ALL_SYMBOLS ON)
	target_link_libraries(CoSimulationManagerLib PUBLIC open_simulation_interface)
else()
	target_link_libraries(CoSimulationManagerLib PUBLIC open_simulation_interface_static)
endif(BUILD_SHARED_LIBS)


## generate grpc code
# custom grcp cpp code generation script that is easier to use than gRPC's default function
include(GenerateGRPC)
# gRPC can handle relative files
set(COSIMA_GRPC_PROTO_FILES
	grpc_proto_files/CoSiMaMessages.proto
	grpc_proto_files/base_interface/BaseInterface.proto
	grpc_proto_files/base_interface/CARLAInterface.proto
	grpc_proto_files/simulation_interface/SimulationInterface.proto
	grpc_proto_files/simulation_interface/OSMPSimulationInterface.proto
)
add_library(CoSimulationManagerGRPCLib ${COSIMA_GRPC_PROTO_FILES})
generate_grpc_cpp(TARGET CoSimulationManagerGRPCLib IMPORT_DIRS ${CONAN_INCLUDE_DIRS_PROTOBUF} ${osi_SOURCE_DIR})
if(BUILD_SHARED_LIBS)
	target_link_libraries(CoSimulationManagerGRPCLib PUBLIC open_simulation_interface)
else()
	target_link_libraries(CoSimulationManagerGRPCLib PUBLIC open_simulation_interface_static)
endif(BUILD_SHARED_LIBS)
target_link_libraries(CoSimulationManagerGRPCLib PUBLIC grpc++)
target_include_directories(CoSimulationManagerGRPCLib BEFORE PUBLIC ${CMAKE_BINARY_DIR}/gens )
target_link_libraries(CoSimulationManagerLib PUBLIC CoSimulationManagerGRPCLib)
# previous include is supposed to propagate, but is missing...
target_include_directories(CoSimulationManagerLib BEFORE PUBLIC ${CMAKE_BINARY_DIR}/gens )# $<TARGET_PROPERTY:CoSimulationManagerGRPCLib,INTERFACE_INCLUDE_DIRECTORIES>)

find_package(Catch2 REQUIRED)
add_executable(test_CoSiMa ${TESTFILES})
target_include_directories(test_CoSiMa PUBLIC ${CMAKE_CURRENT_LIST_DIR}/include ${CMAKE_BINARY_DIR}/gens)
target_link_libraries(test_CoSiMa PRIVATE CoSimulationManagerLib Catch2::Catch2 CoSimulationManagerGRPCLib)

#copy test resources to build folder
add_custom_command(TARGET test_CoSiMa PRE_BUILD
                     COMMAND ${CMAKE_COMMAND} -E
                         make_directory $<TARGET_FILE_DIR:test_CoSiMa>/../test/resources/)
#Feedthrough_cs_me.fmu contains definitions for both me and cs => created copies with edited modelDescription.xml
add_custom_command(TARGET test_CoSiMa PRE_BUILD
                     COMMAND ${CMAKE_COMMAND} -E
                         copy_if_different
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/testconfig-carla.yaml
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/testconfig-dummy.yaml
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/testconfig-osmp.yaml
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/testconfig-combined.yaml
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/testconfig-wrong.yaml
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/testconfig4.yaml
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/Feedthrough_cs.fmu
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/Feedthrough_me.fmu
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/Stair.fmu
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/OSMPCNetworkProxy.fmu
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/OSMPDummySensor.fmu
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/OSMPDummySource.fmu
						 ${CMAKE_CURRENT_LIST_DIR}/test/resources/osmp-grpc-config.yaml
						 $<TARGET_FILE_DIR:test_CoSiMa>/../test/resources/)

include(CTest)
include(Catch)
catch_discover_tests(test_CoSiMa)

add_executable (CoSimulationManager "${CMAKE_CURRENT_LIST_DIR}/src/Main.cpp" "${CMAKE_CURRENT_LIST_DIR}/include/Main.h")
if (${CMAKE_CXX_STANDARD} LESS 17)
	target_link_libraries(CoSimulationManager PUBLIC CoSimulationManagerLib stdc++fs)
else()
	target_link_libraries(CoSimulationManager PUBLIC CoSimulationManagerLib)
endif()
target_include_directories(CoSimulationManager PUBLIC ${CMAKE_CURRENT_LIST_DIR}/include/)
